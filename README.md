[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/1osHQelb)

## Repository Contents
This repository contains 3 programs: 
1) A cpp program that uses the compensated/Kahan sum algorithm to help make arithmetic calculations that may encounter precision error using only the standard library. This program is found in subfolder `csum` with files: `KahanSum.cpp`, `KahanSum.hpp`, `KahanSum.tpp`, `main.cpp`
2) A cpp program that uses the Eigen library to create graph representations of molecules through adjacency matrices, and compute different properties (walks, degrees) of vertices/atoms found in the graph/molecule. This program is found in subfolder `amat` with files: `amat.cpp`, `amat.hpp`, `main.cpp`
3) A python program used to construct a graph representation of a molecule object by extending the functionality of the networkx library to identify and find different characteristics of user chosen molecules. This python program files that the user will mainly need in the repository are: `FinalProject.py`, `UsingArgparse.py`, and `provided.py`. Other optional files that the user does not have to worry about, but can view or use are `.ipynb files`, `Makefile`, and `testcases.py` that were used to draft and test the program during its development. The user may refer to and use`testcases.py` in case they would like to learn more about each method and/or would like to contribute to it.  The repository containing the python program also contains sdf files that the user can source from.

## How to use repository contents
1) <b>To use the cpp program implementing compensated/Kahan sum</b>, the user must first ensure they have access to the appropriate files found in the `csum` subdirectory. This subdirectory includes 4 files: `KahanSum.cpp`, `KahanSum.hpp`, `KahanSum.tpp`, and `main.cpp`. The user may use the `main.cpp` file for their calculations. They may find code that is already written in `main.cpp`. However, the user does not have to worry about the code that already exists in `main.cpp` as it was used for testing purposes by the programmer to ensure the program runs as expected. Looking pass the testcases, the user may create and enter a vector, list, or array container of ordered long doubles (that does not consider uniqueness of elements) that they wish to compute the sum of into `main.cpp` under `int main(void)` and before `return 0`. After creating a container with values to sum, they may call the function KahanSum() (and RegularSum() for comparison) and pass their container type into the functions. The program already considers passing the parameter by reference, so the user does not need to worry about using an extra `&`. To compile and run the code, and assuming the user is in the appropriate folder path, the user needs to type into the terminal: 
```
g++ -std=c++17 main.cpp KahanSum.cpp -o executible
./executible
```

2) <b>To use the cpp program using the Eigen library to create matrix/graph representations of molecules and calculate different properties</b>, the user must first ensure they have access to the appropriate files found in the `amat` subdirectory. This subdirectory includes 3 files: `amat.cpp`, `amat.hpp`, and `main.cpp`. It is assumed that the user has the `Eigen` library installed in a subfolder called `include` in the same directory as the source and header files. The user may use the `main.cpp` file to construct their `Molecule` object. They may find code that is already written in `main.cpp`. However, the user does not have to worry about the code that already exists in `main.cpp` as it was used for testing purposes by the programmer to ensure the program runs as expected. Looking pass the testcases, the user must input a `vector<string>` of single characters representing atoms, and a `vector<pair<int,int>>` representing edges. When creating the edge list, the user will put in make_pair(x,y) for every edge created where x and y are of type int. They will also need to input more pairs, but with x and y switched `make_pair(y,x)`, to represent the same edge specified earlier in the vector. Once constructed, they may call methods `.get_AdjMatrix()`, `.nwalks(double length, const int & atom1_index, const int & atom2_index)`, and `.degrees()` to create a graph representation using an adjacency matrix for their molecule, to compute the number of walks of length `length` between 2 user-defined atoms, and to calculate the degrees of each atom in the molecule. To compile and run the code, and assuming the user is in the appropriate folder path with the correct libraries, the user needs to type into the terminal: `g++ -std=c++17 main.cpp amat.cpp -o executiblename`.
```
g++ -std=c++17 main.cpp amat.cpp -o executible
./executible
```
3) <b>To use the python program that enables users to construct a graph representation of their molecule, perform substructure search, and do different analyses of their molecule</b>: 
   * The user will need the following files: `FinalProject.py`, `UsingArgparse.py`, and `provided.py`. The user may also need to use the terminal to perform substructure search with `UsingArgparse.py` and a separate file of their choice that imports `class Molecule()` from `FinalProject.py` such as `testcases.py` or a .py file of their choosing that contains `if __name__=='__main__'`. The program requires python version no greater than 3.11 and the following different libaries: `networkx`, `networkx.convert`, `matplotlib.pyplot ` `provided.parse_sdf`, `import random`, and `itertools.combinations`. To streamline the process of importing libraries and ensuring the user does not run into technical issues due to package or python version, the user can create an environment with the optional `Makefile` that is included in the repository. To create the environment through the Makefile, the user types `Make environment` into the terminal. After creating the environment, the user may start constructing their graph representation of molecule objects.

   * To construct a molecule graph object using `class Molecule()`, the user can instatiate the object by passing in an sdf file as a string OR a dictionary of nodes and list of edges, where each edge is represented by a tuple containing 3 objects (2 nodes connected by an edge and its edgeweights). For example:
   ```
    # Constructing object with user-defined nodes and edges

    nodes, edges = parse_sdf("sdf/AHJRHEGDXFFMBM-UHFFFAOYSA-N.sdf")
    molecule1 = Molecule(nodes=nodes, edges=edges)
   ```
   ```
    # Constructing object with user-defined sdf file:

    molecule1 = Molecule(sdf="sdf/AHJRHEGDXFFMBM-UHFFFAOYSA-N.sdf")
    ```

   * The constructor contains checks to safeguard the user from invalid entries used to construct the graph representation of their molecule. Once constructed, the  user has a plethora of functions and attributes to choose from to visualize their molecule and analyze/observe. To use the methods or view attributes, for exmaple, they must type out `molecule1.method()` or `molecule1.attribute`. 
   * Such attributes include `.count_rings` to count the number of rings and detect atoms composing each ring of the graphed molecule; `.visualize_molecule` which visualizes and saves the graphed molecule object with vertices following CPK guidelines as a `MyGraphedMolecule.png` file; `.HasAromaticRings` that checks for aromatic rings based on 3 properties (the molecule has cycles, ring has delocalized electrons i.e. has sp2 hybridization or trigonal planar geometry, and satisfies Huckel's rule); `.getHashedPathFingerprint(size=2048, pathlength=7, num_bits_per_hash=5)` which contains default parameters to obtain a unique fingerprint associated with that molecule's atoms and bonds; and an overloaded `==` operator that compares if 2 objects of type `Molecule` are equal to one another based on their fingerprints. 

   * In addition to constructing a Molecule and visualizing/analyzing its structure, the user can also use this program to perform a substructure search. The substructure search will require the use of the terminal, the environment set up through the Makefile, `FinalProject.py`, `provided.py`, and `UsingArgparse.py` files. For the user to perform the substructure search, they must ensure they are in the same directory as the program files and type into the terminal.
   ```
   # terminal: 
   python UsingArgparse.py SearchedMolecule.sdf Substructure.sdf

   # Add --help at the end for more information and introspection.
   python UsingArgparse.py SearchedMolecule.sdf Substructure.sdf --help
   ``` 
   * In the above code block, SearchedMolecule is the molecule the user is searching in for the specified substructure. The user may use any .sdf files found within the sdf subfolder or others they find online. In case the user needs help or would like more information on the substructure search with `UsingArgparse.py`, they can use python introspection by using `--help` in the terminal: `python UsingArgparse.py SearchedMolecule.sdf Substructure.sdf --help`.
   
   * An example of a substructure search for benzene in egcg is included in the Makefile that the user can view. They may run it through the Makefile using `Make substructure_search` or enter into the terminal the same example as above, except use `egcg.sdf` and `benzene.sdf` in place of SearchedMolecule.sdf and Substructure.sdf. 
  
   * In the case the user would like to add or contribute to test cases, or find interesting edge cases they wish to bring more attention to, they may implement the edge case in `testcases.py` and type into the terminal `Make testing` to test the file's cases. 


## C++ (Kahan Sum) Reflection
This program uses 4 files: `KahanSum.cpp`, `KahanSum.hpp`, `KahanSum.tpp`, and `main.cpp`.
The declaration and implementation of the methods `KahanSum()` and `RegularSum()` can be found in `KahanSum.tpp` . Both methods are templated to allow users to compute a sum of numbers found in an ordered container that doesn't require all elements to be unique. Templated functions are stored inside `.tpp` files. However, only `.cpp` files can be compiled. This led me to treat `KahanSum.tpp` very similar to other libraries that are only included and specified in the `.hpp` header files. When the file is called to compile through `g++ -std=c++17 main.cpp KahanSum.cpp -o executiblename`, the C++ programming language will look for main and read in necesary `#includes` through the `.hpp` header file. The compiler will then see the function call in `main.cpp`, then the specified datatype (i.e. vector, list, array, etc.), then looks to the templated function found in the `.tpp` file, and replaces the keyword and generic type `template` and `T` with the specified datatype name (CHEM274A week 6 material). These 2 templated functions were designed to pass the container type in by reference. The container does not get modified inside the function, and passing by reference avoids creating unecessary copies of the container in memory. In addition, const was added to the beginning of each function declaration to make the return value of the functions constant and unchangeable once computed for future use (CHEM274A week 2 and 5 discussion material). These 2 functions also use iterators to iterate through each container. Using iterators is more versatile than using for loops, and allows us to iterate through different container types which is most suitable for implementing function templates capable of working with different containers (CHEM274A week 8 material). Bounds checking is implemented in the 2 templated functions to ensure that our iterator starts adding to the beginning of the container where the largest value should be located.

## C++ (amat) Reflection
This program uses 3 files: `amat.cpp`, `amat.hpp`, and `main.cpp`. The header (`.hpp`) contains all the necessary library files and method declarations. The `amat.cpp` contains the class and method implementations. When designing the `Molecule` class in C++, the constructor takes in a vector<string> of atoms and a vector<pair<int,int>> of bonds (or edges). Both parameters are passed via const reference. The reason for const intfront of user-defined attributes is to ensure they are not mistakenly changed throughout the program. The reason to pass the user-defined attributes by reference is to minimize the amount of space taken up when using them through class methods. Passing by const reference for atom_index parameters for method `nwalks()` is also used for the same reason. The method `nwalks(const vector<string> & atoms, const vector<pair<int,int>> & bonds)` also includes bounds checking for the 2nd and 3rd passed in parameter specifying an atom through indexing into a vector of atoms. The bounds checking prevents the user from entering invalid indices that are out of the bounds of the vector before calculating nwalks between 2 atoms. For method `const MatrixXd get_AdjMatrix()`, I am making the return type a const MatrixXd because the AdjMatrix that is returned from this getter method is used in other methods. When a getter method returns a value that is used in other methods, or if it is called in other methods, it is best to keep the output as const to protect the user from modifying an object that other functions depend on. The use of returning a const output is also used for `const VectorXi get_degrees()` for the same reason as `const MatrixXd get_AdjMatrix()` and, in general, other getter methods. The class contains another constructor for deep copying. When designing molecule classes, I prefer to have the deep copy constructor, especially if I want to create another `Molecule` object that is almost similar to an existing `Molecule` object, but with slight modification or add-ons without accidently modifying the original `Molecule` object. When implementing the deep copy constructor, the object being copied is held constant with `const` so that we do not accidentally modify the original object. When any `Molecule` object is instantiated, it takes up memory, so a destructor was included to free that memory. Data is stored in memory until variables / function calls go out of scope and when the destructor is called.

## Python Reflection
- The `Molecule` class implmented in `FinalProject.py` uses a graph representation of a molecule. The `Molecule` class is also a subclass that inherits  from the `networkx` library. To implement the `Molecule` class, object oriented programming (OOP) is used with inheritence by treating networkx as a package that is inherited by sub classes like `Digraph` class, or in our case, `Molecule` class. OOP is defined with "the concept of _object_, which can contain data and code" (Chem274A week 2 async lecture). Through inheritence, `Molecule` class is able to take on all the methods/behaviors/attributes/properties that the networkx library has (and more) by treating the networkx library as an object holding methods and attributes. Inheritence was used instead of other methods (such as composition) because it enables the programmer (me) to use networkx functions within the class methods built for specific use cases and extend the functionality of the superclass. Code would not have to be repeated for the same use case, otherwise that would be violating the Don't repeat yourself (DRY) principle (CHEM274A material discussion 8 on Don't-Repeat-Yourself). Keeping DRY in mind when building a program would reduce the amount of time to code, and leave less room for error since it is assumed that popular open-source libraries like `networkx` have been optimized after thorough review/revisions. This is also the reason why inheritence was used over composition to build the `Molecule` class in this repository. If composition was used, I would have to call functions like `parse_sdf()`, `nx.add_nodes_from()`, and `add_weighted_edges_from()` multiple times to construct different graph representations of my molecules and also when building subgraphs in my method `def _hash(self, nodes, path)`. In `def _hash(self, nodes, path)` the program calls class `Molecule` again to create subgraphs of different paths for hashing. This is an example of OOP and the use of the DRY since I am creating many objects through one line of code that places all the methods packaged inside the instatiated `Molecule` object. Although creating graph representations of molecules with the same use cases can be done with composition, DRY would be much harder to ensure through repeated written-out functions used to compose graph representations of the same object types. Although composition may increase the amount of objects and use of object oriented programming, it may also increase the amount of unnecessary code to write compared to inheritence.
- An important point to note about inheritance is that it is meant to add-on and extend the ability of the superclass through the child class. It is not meant to over-write attributes/methods of the superclass (CHEM274A week 2 async material). This means we must use `super().__init__()` to ensure we at least consider all attributes and methods that is part of networkx when adding on to its ability through a childclass. Optional parameters for `incoming_graph_data` noted in the networkx's documentation for the constructor is `None` by default, which is why our `super().__init__()` does not have paramters passed in. Using `super().__init__()` ensures that our `Molecule` class has all methods/attributes that the user may want to use/see from the superclass. When adding additional attributes to the childclass constructor such as `sdf`, `nodes`, and `edges`; it is very important that we do not overwrite any attributes or methods of networkx that is encapsulated and hidden/abstracted by `super().__init__()` (week 2 of chem274A). Overwriting attributes/methods may conflict with methods that exist for networkx due to the chance of datatypes being different or structured differently. This is why my `Molecule` class constructor has additional attributes for nodes and edges noted as `self.nodess` and `self.edgess` and not `self.nodes` and `self.edges` because our child class' additional class arguments should not overwrite the ones existing through the constructor of the `networkx.Graph` superclass. It was also observed through online documentation that other subclasses, such as the `DiGraph` class, is a subclass/extension of networkx's `Graph` class. In the documentation, the `DiGraph` constructor contained a method `convert.to_networkx_graph()` to convert any instances of the class into the appropriate graph datatype used in other networkx functions.
- When designing `def getHashedPathFingerprint(self, size, pathlength, num_bits_per_hash)` a list of edges were obtained using `nx.all_simple_paths()` which performs dfs to obtain paths of lengths 1 to `pathlength` starting from node `i` and ending at node `j`. The output is a list of edges represented by uniquely identified atoms. These paths and edges are stored in list `MyPaths`, but they do not consider the molecules bonds/edgeweights yet. Since we must ensure edges of the same atoms/vertices are different from other edges with the same atoms/vertices, and  thus ensuring the same atoms with different bonds like COH vs. C=O are recognized differently, we must take into account edgeweights when generating the molecular fingerprint. A list `bonds` was created to store edges with weights. Pairs of nodes in list `MyPaths` are chcked against `self.edgess` where associated edges and edgeweights are considered, obtained, and stored in `bonds`. The list `bonds` storing edges and edgeweights of different paths are passed into a hash function that is then used to help generate the molecular fingerprint.

- When designing `def HasAromaticRings()` it will return `True` if a molecule has at least 1 aromatic ring, or `False` if no aromtic ring is in the molecule. For a ring to be aromatic, it must meet 4 conditions: (1) the ring is cyclic, (2) the ring is planar (trigonal/sp2 hybridized atoms), (3) the ring is conjugated (i.e. the electrons are delocalized and every atom has a p-orbital), (4) and it meets Huckels rule that defines the number of pi electrons involved in aromaticity (4n+2), where n is an integer greater than 0. 

  1) To check if a molecule has any cyclic rings, `self.count_rings()` is called to calculate the number of rings in the molecule. If the return to `rings` is greater than 0, then the molecule has a cycle. This method also returns `Atoms_in_cycle` which is obtained with the help of using `nx.cycle_basis()` inside the method. `nx.cycle_basis()` performs a search and returns a list of atoms that are in the ring in the order that they were discovered.
  2) Next, every atom in the ring is checked for sp2 hybridization that allows for delocalized electrons to travel around the ring. Using benzene as an example, every carbon in its ring is sp2 hybridized (it has 1 double and 2 single bonds for a total of 3 electron domains to form trigonal planar geometry). Since it is assumed that our rings (if any) are planar, and keeping benzene in mind as the method was written, we can assume that benzene will have at least 1 bond to hydrogen that has been accounted for. That means we need to check if every edge in the ring alternates between single and double bonds. To do this, new list `BondsOfAllCycles` is created to store lists of edges and edgeweights of each cycles in the molecule. For each cycle in the molecule a list `Bonds` is instantiated to store edgeweights of cycles. Because `nx.cycle_basis()` only returns a list of atoms found in rings, we need to create the atom pairs that represent the ring's edges. For every edge of every cycle in the molecule, (Node,Node) pairs are created and are stored in list `edges`. For an edge in `edges`, we find the corresponding pair of vertices that match to an edge in `self.edges` that also store edges, but with weights. Once a match is found, the weight of that edge is stored in list `Bonds` (side note: this method of getting bond information after using a networkx method is also used when generating fingerprints, and extends the use of the networkx library and the concept of inheritance.) We then check for alternating single and double bonds through the list `Bonds` by making sure adjacent items in the list are not equal through, and that the first and last bonds in list `Bonds` are not equal. This also ensures equivalent resonance structures are recognized. If the adjacent bonds are not equal, and assuming we already have a trigonal planar ring, then we have a conjugated ring. 
  3) After checking that we have cycles, and that at least 1 of those cycles are delocalized, we can check for the number of pi electrons to see if it satisfes huckel's rule. To check for the number of pi electrons, we set `pi_electrons = 2*Num_DoubleBonds` where Num_DoubleBonds is a count of edges that have an edgeweight of 2 in the cycle. We then check that n is a non-negative number in Huckel's rule. If it is, then this final check ensures that our molecule has an aromatic ring.
- The equality operator is overloaded within the class `Molecule` with `def __eq__()` to check if 2 objects instantiated by our class `Molecule` are equal. To determine if they are equal, their molecular fingerprint is used for comparison. When overloading an operator, it is always best to practice defensive programming by ensuring your objects using the overloaded operator are of the same type (CHEM274A week10 async material on operator overloading). The molecular fingerprint is implemented in a way to represent the structure of the molecule based on the atoms, edges/connectivity, and edgeweights that the molecule has. Because the user can construct a `Molecule` object with only a dictionary of nodes/atoms and a list of edges/edgeweights, or an sdf file that is parsed to obtain the same nodes/atoms and edges/edgeweights, our molecules can only be compared using these structures. Although it takes time to create an algorithm that generates a molecular fingerprint using these structures, the  algorithm may be more efficient than comparing many nodes/edges of a dictionary or list of tuples representing the graph of many molecules, with possibility that some individual molecules could be represented by large, dense graphs. Comparing fingerprints over dictionaries and nested lists of nodes/atoms leads to cost savings in terms of time in the future when a user has a large amount of molecules vs comparing a bit string that captures a lot of information in a short amount of time and space. Although not implemented here, structural keys can be used, but are much slower and lack generality compared to fingerprints.
- A substructure search is implemented using `Argparse` in `UsingArgparse.py`, and can be used by the user through the terminal. The reason why I used `Argparse` over `sys.argv` (both from week 13 of CHEM274A) is because `sys.argv` is known to have more limitations than `Argparse`. With `Argparse`, we have more control over arguments and error checking. We can also use introspection because it generates `help()` automatically by specifying `help` in the terminal: `python file.py --help`. Arguments can also be specified as optional using `Argparse`. Although there are no optional arguments in my implementation, it is still nice to leave room for it for the future in the event that a complicated edge case is brought to attention. Within `UsingArgparse.py` a substructure search was implemented in a way that closely resembles the methods used to complete CHEM274A's lab 5 on cheminformatics and RDKit. Once 2 fingerprints are generated for comparison and substructure search, and if the substructure exists in the larger molecule, the indices where a 1 is present in the fingerprint of the substructure should also be found to have a 1 in the same index locations in the larger molecule's fingerprint.
- Private methods or attributes were marked with an `_` before its declaration in `FinalProject.py`. For example `def _hash(self, nodes, path)` is a private method that the user will not see, or is assumed to never use or modify. In addition, the `@property` decorator is used to disguise methods as attributes, and to abstract the fact that user-assumed properties calculated at `Molecule` instantiation are actually methods. This type of abstraction further helps create safer and more reliable software to use (CHEM274A week 10 async material).