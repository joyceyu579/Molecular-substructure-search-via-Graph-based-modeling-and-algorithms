[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/1osHQelb)

## Repository Contents
This repository contains 3 files used to run a cpp program that uses the Eigen library to create graph representation of molecules through adjacency matrices, and compute different properties (walks, degrees) of items found in the graph/molecule: `amat.cpp`, `amat.hpp`, `main.cpp`

## How to use repository contents
<b>To use the cpp program using the Eigen library to create matrix/graph representations of molecules and calculate different properties</b>, the user must first ensure they have access to the appropriate files found in the `amat` subdirectory. This subdirectory includes 3 files: `amat.cpp`, `amat.hpp`, and `main.cpp`. It is assumed that the user has the `Eigen` library installed in a subfolder called `include` in the same directory as the source and header files. The user may use the `main.cpp` file to construct their `Molecule` object. They may find code that is already written in `main.cpp`. However, the user does not have to worry about the code that already exists in `main.cpp` as it was used for testing purposes by the programmer to ensure the program runs as expected. Looking pass the testcases, the user must input a `vector<string>` of single characters representing atoms, and a `vector<pair<int,int>>` representing edges. When creating the edge list, the user will put in make_pair(x,y) for every edge created where x and y are of type int. They will also need to input more pairs, but as make_pair(y,x), to represent the same edge specified in beginning parts of the vector representing edges. Once constructed, they may call methods `.get_AdjMatrix()`, `.nwalks(double length, const int & atom1_index, const int & atom2_index)`, and `.degrees()` to create a graph representation using an adjacency matrix for their molecule, to compute the number of walks of length `length` between 2 user-defined atoms, and to calculate the degrees of each atom in the molecule. To compile and run the code, and assuming the user is in the appropriate folder path with the correct libraries, the user needs to type into the terminal: 
```
g++ -std=c++17 main.cpp amat.cpp -o executible
./executible
```

## C++ (amat) Reflection
This program uses 3 files: `amat.cpp`, `amat.hpp`, and `main.cpp`. The header (`.hpp`) contains all the necessary library files and method declarations. The `amat.cpp` contains the class and method implementations. When designing the `Molecule` class in C++, the constructor takes in a vector<string> of atoms and a vector<pair<int,int>> of bonds (or edges). Both parameters are passed via const reference. The reason for const intfront of user-defined attributes is to ensure they are not mistakenly changed throughout the program. The reason to pass the user-defined attributes by reference is to minimize the amount of space taken up when using them through class methods. Passing by const reference for atom_index parameters for method `nwalks()` is also used for the same reason. The method `nwalks(const vector<string> & atoms, const vector<pair<int,int>> & bonds)` also includes bounds checking for the 2nd and 3rd passed in parameter specifying an atom through indexing into a vector of atoms. The bounds checking prevents the user from entering invalid indices that are out of the bounds of the vector before calculating nwalks between 2 atoms. For method `const MatrixXd get_AdjMatrix()`, I am making the return type a const MatrixXd because the AdjMatrix that is returned from this getter method is used in other methods. When a getter method returns a value that is used in other methods, or if it is called in other methods, it is best to keep the output as const to protect the user from modifying an object that other functions depend on. The use of returning a const output is also used for `const VectorXi get_degrees()` for the same reason as `const MatrixXd get_AdjMatrix()` and, in general, other getter methods. The class contains another constructor for deep copying. When designing molecule classes, I prefer to have the deep copy constructor, especially if I want to create another `Molecule` object that is almost similar to an existing `Molecule` object, but with slight modification or add-ons without accidently modifying the original `Molecule` object. When implementing the deep copy constructor, the object being copied is held constant with `const` so that we do not accidentally modify the original object. When any `Molecule` object is instantiated, it takes up memory, so a destructor was included to free that memory. Data is stored in memory until variables / function calls go out of scope and when the destructor is called.
